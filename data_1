"""
data.py
========
Simulated and real ECG data utilities.
---------------------
This module provides tools for generating synthetic ECG signals
and loading real data from CSV or PhysioNet.

Learning objectives:
- Understand how ECG waveforms can be *modeled* using simple sinusoids.
- Learn practical data handling (loading files, managing shapes, reproducibility).
"""

import numpy as np
import pandas as pd


def simulate_ecg(duration=10, fs=250, heart_rate_bpm=70, noise_std=0.2, random_seed=None):
    """
    Simulate an ECG-like waveform with Gaussian R-peaks.

    Parameters
    ----------
    duration : float
        Signal length in seconds.
    fs : int
        Sampling rate (Hz).
    heart_rate_bpm : float
        Target mean heart rate (beats per minute).
    noise_std : float
        Standard deviation of Gaussian noise added to signal.
    random_seed : int, optional
        Seed for reproducibility.

    Returns
    -------
    t : np.ndarray
        Time vector (seconds).
    signal : np.ndarray
        Synthetic ECG-like waveform.
    fs : int
        Sampling rate.

    Educational concept
    -------------------
    - Combines periodic sinusoids (heart rhythm) + Gaussian spikes (R-peaks).
    - Mimics an ECG morphology for algorithm testing without real patient data.
    """
    if random_seed is not None:
        np.random.seed(random_seed)

    # Create time vector
    t = np.linspace(0, duration, int(duration * fs), endpoint=False)

    # Convert HR from bpm → Hz
    hr_hz = heart_rate_bpm / 60.0

    # Base sinusoid = heartbeat rhythm
    base = np.sin(2 * np.pi * hr_hz * t)

    # Add harmonics for more realistic ECG shape
    harm = 0.25 * np.sin(2 * np.pi * 2 * hr_hz * t) + 0.1 * np.sin(2 * np.pi * 3 * hr_hz * t)
    signal = base + harm

    # Add Gaussian peaks to simulate R-waves
    beat_times = np.arange(0, duration, 1.0 / hr_hz)
    for bt in beat_times:
        sigma = 0.01  # narrow = sharp peaks
        signal += np.exp(-0.5 * ((t - bt) / sigma) ** 2)

    # Add Gaussian noise
    signal += noise_std * np.random.randn(len(t))

    return t, signal, fs


def load_csv_ecg(path, column=None):
    """
    Load ECG-like data from a CSV file (various shapes supported).

    Parameters
    ----------
    path : str
        Path to CSV file.
    column : int, optional
        Column index to load (if multiple columns exist).

    Returns
    -------
    signal : np.ndarray
        Loaded ECG waveform.

    Educational note
    ----------------
    Handles three typical data formats:
    1. One row with many columns (1×N)
    2. One column with many rows (N×1)
    3. Multi-column (time + signal) → extract selected column.
    """
    df = pd.read_csv(path, header=None)

    # 1. Single row, many columns → return that row
    if df.shape[0] == 1 and df.shape[1] > 1:
        return df.iloc[0].values

    # 2. Single column, many rows → return that column
    if df.shape[1] == 1:
        return df.iloc[:, 0].values

    # 3. Multi-column, use specified column
    if column is not None and column < df.shape[1]:
        return df.iloc[:, column].values

    # Default fallback: return first column
    return df.iloc[:, 0].values


def load_wfdb_record(record_name, pn_dir='mitdb'):
    """
    Load an ECG signal from PhysioNet (WFDB format).

    Parameters
    ----------
    record_name : str
        Record name (e.g., '100' for MIT-BIH).
    pn_dir : str
        PhysioNet database directory.

    Returns
    -------
    t : np.ndarray
        Time vector (s)
    sig : np.ndarray
        ECG waveform
    fs : float
        Sampling frequency

    Educational note
    ----------------
    - WFDB (WaveForm DataBase) is a standard biomedical signal format.
    - Accesses open ECG databases (e.g., MIT-BIH Arrhythmia).
    - Requires the `wfdb` Python package to be installed.
    """
    try:
        import wfdb
    except Exception as e:
        raise RuntimeError("wfdb package required. Install with: pip install wfdb") from e

    # Read record from PhysioNet
    record = wfdb.rdrecord(record_name, pn_dir=pn_dir)

    sig = record.p_signal[:, 0]   # use first channel
    fs = record.fs                # sampling rate
    t = np.arange(len(sig)) / fs  # create time vector

    return t, sig, fs


